# **final deliveriables**

Overview:
our goals for the final project were implementing three graph algorithms, namely the Breadth First Traversal, Dijkstra's shortest path algorithm, and the A* search algorithm based on the openflghts dataset (https://openflights.org/data.html) to find the shortest path or best path between two airports. I believe that we have successfully achieved the goals. In this results.md file, I will introduce the functionality of our code, show how do they work to solve the real world problem proposed by us. all algorithm are believed to be successfully implemented. tests and output of functions can be found in output folder.

## Breadth First Traversal
we implementeed the BFS traversal inside graph.cpp. it will takes an empty int vector and the start airport's id as function input. By running the function in the main.cpp, the BFS will modify the input int vector. If the input is valid (could be found in the maps in the graph class), it will the traversed airports in the form of their airport ID. if the input is not valid, the bfs will return a line inform the user the input cannot be used to do BFS traversal. The outputs are stored in the output folder, the corresponding traversal output file (in .txt) will be updated after each time the user run the BFS in the main function. BFS functionality could be either checked by the output file and the test cases in test.cpp.

## Dijkstra's shortest path
Dijkstra's algorithm is also implemented in graph.cpp. It takes the BFS output, which is a modified int vector that contains all traversed airports' id, the start airport's id, and an empty int to int map as the input. Our Dijkstra's will traversed the whole graph and records all shortest paths from the given starting point to all vertices in the BFS traversed list. We can retrive the exact path by passing the id of destination airport to the map. Since the map maps the node and its preceding node, we can either printed the path out like what we did int the main function or stores them in a vector like what we did in the test.cpp. The clear output can be checked when you run the main function by entering the Dijkstra's case. The functionality was verified and proved in the test.cpp.

## A* search 
we implemented the A* search in graph.cpp. The function itself will take two airport IDs: one for the start airport, one for the destination airport, as well as an empty int vector as inputs. Its output will be a modified int vector which records the result path in reversed order. Our heuristic function takes the distance (calculated using longtitude and latitude instead, ignoring whether there will be routes in between) from the next possible connected node to the destination airport as estimated value. This function, given the huge dataset and relative lower stability compared to Dijkstra's, which traversed the whole graph and tracked the shortest path in distance, may give a path that is not genuinely "best" in terms of distance. It may takes fewer airports to get to the destination, but not shorter distances in total when compared with the Dijkstra's path. But we did successfully implemented the A* even though our estimated value could be optimized if there is other route information such as cost. A* each time will takes the next node with consideration of their distance (in terms of longtitude and latitude) to the destination, and this will lead the A* giving a different path start from a certain point. Example and illustration about this case is also discussed in the test.cpp file. We focused on testing how A* search's use of estimated value lead it to different choice compared to Dijkstra's algorithm. 